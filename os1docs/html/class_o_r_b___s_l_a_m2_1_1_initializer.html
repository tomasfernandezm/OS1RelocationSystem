<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::Initializer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_initializer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_initializer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::Initializer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inicializador de mapa en modo monocular.  
 <a href="class_o_r_b___s_l_a_m2_1_1_initializer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_initializer_8h_source.html">Initializer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a40d41840e2bdb7199ab024871d028c2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a40d41840e2bdb7199ab024871d028c2c">Initialize</a> (const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;CurrentFrame, const vector&lt; int &gt; &amp;vMatches12, cv::Mat &amp;R21, cv::Mat &amp;t21, vector&lt; cv::Point3f &gt; &amp;vP3D, vector&lt; bool &gt; &amp;vbTriangulated)</td></tr>
<tr class="memdesc:a40d41840e2bdb7199ab024871d028c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa en paralelo una matriz fundamental y una homografía.  <a href="#a40d41840e2bdb7199ab024871d028c2c">More...</a><br /></td></tr>
<tr class="separator:a40d41840e2bdb7199ab024871d028c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac492345a970665cd8a1b1d8cf41d44af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ac492345a970665cd8a1b1d8cf41d44af">Initializer</a> (const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;ReferenceFrame, float sigma=1.0, int iterations=200)</td></tr>
<tr class="memdesc:ac492345a970665cd8a1b1d8cf41d44af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor que toma ReferenceFrame como referencia para los sucesivos intentos de inicialización.  <a href="#ac492345a970665cd8a1b1d8cf41d44af">More...</a><br /></td></tr>
<tr class="separator:ac492345a970665cd8a1b1d8cf41d44af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad0bf21297bc6271e7d014ce41d6ff7d4"><td class="memItemLeft" align="right" valign="top">typedef pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">Match</a></td></tr>
<tr class="separator:ad0bf21297bc6271e7d014ce41d6ff7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1c8b74679a5cb1af16c07c8a00c8e8c0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a1c8b74679a5cb1af16c07c8a00c8e8c0">CheckFundamental</a> (const cv::Mat &amp;F21, vector&lt; bool &gt; &amp;vbMatchesInliers, float sigma)</td></tr>
<tr class="memdesc:a1c8b74679a5cb1af16c07c8a00c8e8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalúa la calidad de la matriz fundamental, haciendo una verificación epipolar.  <a href="#a1c8b74679a5cb1af16c07c8a00c8e8c0">More...</a><br /></td></tr>
<tr class="separator:a1c8b74679a5cb1af16c07c8a00c8e8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ac8374ca2a993b8cddc88703ffbe9a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ac2ac8374ca2a993b8cddc88703ffbe9a">CheckHomography</a> (const cv::Mat &amp;H21, const cv::Mat &amp;H12, vector&lt; bool &gt; &amp;vbMatchesInliers, float sigma)</td></tr>
<tr class="memdesc:ac2ac8374ca2a993b8cddc88703ffbe9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalúa la calidad de la homografía, haciendo una verificación epipolar.  <a href="#ac2ac8374ca2a993b8cddc88703ffbe9a">More...</a><br /></td></tr>
<tr class="separator:ac2ac8374ca2a993b8cddc88703ffbe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e79f6486468cde9abd87b873d840e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a72e79f6486468cde9abd87b873d840e7">CheckRT</a> (const cv::Mat &amp;R, const cv::Mat &amp;t, const vector&lt; cv::KeyPoint &gt; &amp;vKeys1, const vector&lt; cv::KeyPoint &gt; &amp;vKeys2, const vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">Match</a> &gt; &amp;vMatches12, vector&lt; bool &gt; &amp;vbInliers, const cv::Mat &amp;K, vector&lt; cv::Point3f &gt; &amp;vP3D, float th2, vector&lt; bool &gt; &amp;vbGood, float &amp;parallax)</td></tr>
<tr class="memdesc:a72e79f6486468cde9abd87b873d840e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica la pose para confirmar hipótesis de H o F.  <a href="#a72e79f6486468cde9abd87b873d840e7">More...</a><br /></td></tr>
<tr class="separator:a72e79f6486468cde9abd87b873d840e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca077af095ae1de08ebb473af670d1d"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#aaca077af095ae1de08ebb473af670d1d">ComputeF21</a> (const vector&lt; cv::Point2f &gt; &amp;vP1, const vector&lt; cv::Point2f &gt; &amp;vP2)</td></tr>
<tr class="memdesc:aaca077af095ae1de08ebb473af670d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa la matriz fundamental para una dada correspondencia de puntos normalizados en dos imágenes, mediante SVD.  <a href="#aaca077af095ae1de08ebb473af670d1d">More...</a><br /></td></tr>
<tr class="separator:aaca077af095ae1de08ebb473af670d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d5aa375ed03336cc0dc981861b15da"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a16d5aa375ed03336cc0dc981861b15da">ComputeH21</a> (const vector&lt; cv::Point2f &gt; &amp;vP1, const vector&lt; cv::Point2f &gt; &amp;vP2)</td></tr>
<tr class="memdesc:a16d5aa375ed03336cc0dc981861b15da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa una homografía para una dada correspondencia de puntos normalizados en dos imágenes.  <a href="#a16d5aa375ed03336cc0dc981861b15da">More...</a><br /></td></tr>
<tr class="separator:a16d5aa375ed03336cc0dc981861b15da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e9e1a14ee76f6cab0f734fa95793af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a78e9e1a14ee76f6cab0f734fa95793af">DecomposeE</a> (const cv::Mat &amp;E, cv::Mat &amp;R1, cv::Mat &amp;R2, cv::Mat &amp;t)</td></tr>
<tr class="memdesc:a78e9e1a14ee76f6cab0f734fa95793af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descompone la matriz esencial E en matrices de rotación y vector traslación.  <a href="#a78e9e1a14ee76f6cab0f734fa95793af">More...</a><br /></td></tr>
<tr class="separator:a78e9e1a14ee76f6cab0f734fa95793af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387c406706472859415c0e7a3594ea04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a387c406706472859415c0e7a3594ea04">FindFundamental</a> (vector&lt; bool &gt; &amp;vbInliers, float &amp;score, cv::Mat &amp;F21)</td></tr>
<tr class="memdesc:a387c406706472859415c0e7a3594ea04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa la matriz fundamental entre los dos cuadros macheados, usando RANSAC.  <a href="#a387c406706472859415c0e7a3594ea04">More...</a><br /></td></tr>
<tr class="separator:a387c406706472859415c0e7a3594ea04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0465b2affed7453d30dd85672e9093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a5b0465b2affed7453d30dd85672e9093">FindHomography</a> (vector&lt; bool &gt; &amp;vbMatchesInliers, float &amp;score, cv::Mat &amp;H21)</td></tr>
<tr class="memdesc:a5b0465b2affed7453d30dd85672e9093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca la homografía entre los dos cuadros macheados, usando RANSAC.  <a href="#a5b0465b2affed7453d30dd85672e9093">More...</a><br /></td></tr>
<tr class="separator:a5b0465b2affed7453d30dd85672e9093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ce7aa73741d900d2becc0d8f14c1af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a44ce7aa73741d900d2becc0d8f14c1af">Normalize</a> (const vector&lt; cv::KeyPoint &gt; &amp;vKeys, vector&lt; cv::Point2f &gt; &amp;vNormalizedPoints, cv::Mat &amp;T)</td></tr>
<tr class="memdesc:a44ce7aa73741d900d2becc0d8f14c1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce puntos con las coordenadas normalizadas de los puntos singulares.  <a href="#a44ce7aa73741d900d2becc0d8f14c1af">More...</a><br /></td></tr>
<tr class="separator:a44ce7aa73741d900d2becc0d8f14c1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60796f88f1b3e981ad925a8b566f6315"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a60796f88f1b3e981ad925a8b566f6315">ReconstructF</a> (vector&lt; bool &gt; &amp;vbMatchesInliers, cv::Mat &amp;F21, cv::Mat &amp;K, cv::Mat &amp;R21, cv::Mat &amp;t21, vector&lt; cv::Point3f &gt; &amp;vP3D, vector&lt; bool &gt; &amp;vbTriangulated, float minParallax, int minTriangulated)</td></tr>
<tr class="memdesc:a60796f88f1b3e981ad925a8b566f6315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica las 4 hipótesis de rototraslación obtenidas de la matriz fundamental.  <a href="#a60796f88f1b3e981ad925a8b566f6315">More...</a><br /></td></tr>
<tr class="separator:a60796f88f1b3e981ad925a8b566f6315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc1c05d3b7a5ae35805f69b50f368ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#addc1c05d3b7a5ae35805f69b50f368ea">ReconstructH</a> (vector&lt; bool &gt; &amp;vbMatchesInliers, cv::Mat &amp;H21, cv::Mat &amp;K, cv::Mat &amp;R21, cv::Mat &amp;t21, vector&lt; cv::Point3f &gt; &amp;vP3D, vector&lt; bool &gt; &amp;vbTriangulated, float minParallax, int minTriangulated)</td></tr>
<tr class="memdesc:addc1c05d3b7a5ae35805f69b50f368ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica las 8 hipótesis de rototraslación de Faugeras obtenidas de la homografía.  <a href="#addc1c05d3b7a5ae35805f69b50f368ea">More...</a><br /></td></tr>
<tr class="separator:addc1c05d3b7a5ae35805f69b50f368ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdf78e0f16be44b5ab312aac5cac5af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a3bdf78e0f16be44b5ab312aac5cac5af">Triangulate</a> (const cv::KeyPoint &amp;kp1, const cv::KeyPoint &amp;kp2, const cv::Mat &amp;P1, const cv::Mat &amp;P2, cv::Mat &amp;x3D)</td></tr>
<tr class="memdesc:a3bdf78e0f16be44b5ab312aac5cac5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangula los puntos 3D partir de sus vistas desde ambas cámaras.  <a href="#a3bdf78e0f16be44b5ab312aac5cac5af">More...</a><br /></td></tr>
<tr class="separator:a3bdf78e0f16be44b5ab312aac5cac5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a557fe4d78becc1dda7a26c71d2254336"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a557fe4d78becc1dda7a26c71d2254336">mK</a></td></tr>
<tr class="memdesc:a557fe4d78becc1dda7a26c71d2254336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matriz de calibración, intrínseca o de cámara.  <a href="#a557fe4d78becc1dda7a26c71d2254336">More...</a><br /></td></tr>
<tr class="separator:a557fe4d78becc1dda7a26c71d2254336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9647dedc212bd1fe05084ec7875a05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a8d9647dedc212bd1fe05084ec7875a05">mMaxIterations</a></td></tr>
<tr class="memdesc:a8d9647dedc212bd1fe05084ec7875a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantidad máxima de iteraciones al aplicar RanSaC.  <a href="#a8d9647dedc212bd1fe05084ec7875a05">More...</a><br /></td></tr>
<tr class="separator:a8d9647dedc212bd1fe05084ec7875a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad588868e84cb1b7e256928dd0d50baee"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad588868e84cb1b7e256928dd0d50baee">mSigma</a></td></tr>
<tr class="memdesc:ad588868e84cb1b7e256928dd0d50baee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desvío estándar y variancia.  <a href="#ad588868e84cb1b7e256928dd0d50baee">More...</a><br /></td></tr>
<tr class="separator:ad588868e84cb1b7e256928dd0d50baee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af4e0e177bb75879dac174b758ce7d4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a7af4e0e177bb75879dac174b758ce7d4">mSigma2</a></td></tr>
<tr class="separator:a7af4e0e177bb75879dac174b758ce7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90762e82702f06f6999672ebaa4cb8"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a3a90762e82702f06f6999672ebaa4cb8">mvbMatched1</a></td></tr>
<tr class="memdesc:a3a90762e82702f06f6999672ebaa4cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marcas de macheos.  <a href="#a3a90762e82702f06f6999672ebaa4cb8">More...</a><br /></td></tr>
<tr class="separator:a3a90762e82702f06f6999672ebaa4cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a8bce28d125446b4607f12041c7c13"><td class="memItemLeft" align="right" valign="top">vector&lt; cv::KeyPoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#aa4a8bce28d125446b4607f12041c7c13">mvKeys1</a></td></tr>
<tr class="memdesc:aa4a8bce28d125446b4607f12041c7c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntos singulares del cuadro 1.  <a href="#aa4a8bce28d125446b4607f12041c7c13">More...</a><br /></td></tr>
<tr class="separator:aa4a8bce28d125446b4607f12041c7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034e9d495b47667f3e0bf0bc3190ff05"><td class="memItemLeft" align="right" valign="top">vector&lt; cv::KeyPoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a034e9d495b47667f3e0bf0bc3190ff05">mvKeys2</a></td></tr>
<tr class="memdesc:a034e9d495b47667f3e0bf0bc3190ff05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntos singulares del cuadro 2.  <a href="#a034e9d495b47667f3e0bf0bc3190ff05">More...</a><br /></td></tr>
<tr class="separator:a034e9d495b47667f3e0bf0bc3190ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ef04be7036e4629a8b3fa05c7327f5"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">Match</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ac4ef04be7036e4629a8b3fa05c7327f5">mvMatches12</a></td></tr>
<tr class="memdesc:ac4ef04be7036e4629a8b3fa05c7327f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macheos.  <a href="#ac4ef04be7036e4629a8b3fa05c7327f5">More...</a><br /></td></tr>
<tr class="separator:ac4ef04be7036e4629a8b3fa05c7327f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572144f600b28828d4772b0470206afe"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a572144f600b28828d4772b0470206afe">mvSets</a></td></tr>
<tr class="memdesc:a572144f600b28828d4772b0470206afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjuntos para Ransac.  <a href="#a572144f600b28828d4772b0470206afe">More...</a><br /></td></tr>
<tr class="separator:a572144f600b28828d4772b0470206afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Inicializador de mapa en modo monocular. </p>
<p>Procura la triangulación de los primeros puntos del mapa. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad0bf21297bc6271e7d014ce41d6ff7d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef pair&lt;int,int&gt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">ORB_SLAM2::Initializer::Match</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac492345a970665cd8a1b1d8cf41d44af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::Initializer::Initializer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>ReferenceFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>200</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor que toma ReferenceFrame como referencia para los sucesivos intentos de inicialización. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReferenceFrame</td><td>Cuadro de referencia inicial, el primero de las dos vistas necesarias para la triangulación. </td></tr>
    <tr><td class="paramname">sigma</td><td></td></tr>
    <tr><td class="paramname">iterations</td><td>Cantidad máxima de iteraciones para cada intento de triangulación. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c8b74679a5cb1af16c07c8a00c8e8c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::Initializer::CheckFundamental </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>F21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbMatchesInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evalúa la calidad de la matriz fundamental, haciendo una verificación epipolar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F21</td><td>Matriz fundamental. </td></tr>
    <tr><td class="paramname">vbMatchesInliers</td><td>Resultado, marca de puntos singulares que pasaron el test. </td></tr>
    <tr><td class="paramname">sigma</td><td>Sigma establece el umbral de prueba. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resultado de la evaluación. Mayor, mejor.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a387c406706472859415c0e7a3594ea04" title="Computa la matriz fundamental entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindFundamental</a>. </p>

</div>
</div>
<a id="ac2ac8374ca2a993b8cddc88703ffbe9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::Initializer::CheckHomography </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>H21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>H12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbMatchesInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evalúa la calidad de la homografía, haciendo una verificación epipolar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H21</td><td>Matriz de transformación homográfica. </td></tr>
    <tr><td class="paramname">H12</td><td>Inversa de H21. </td></tr>
    <tr><td class="paramname">vbMatchesInliers</td><td>Resultado, marca de puntos singulares que pasaron el test. </td></tr>
    <tr><td class="paramname">sigma</td><td>Sigma establece el umbral de prueba. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resultado de la evaluación. Mayor, mejor.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a5b0465b2affed7453d30dd85672e9093" title="Busca la homografía entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindHomography</a>. </p>

</div>
</div>
<a id="a72e79f6486468cde9abd87b873d840e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Initializer::CheckRT </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::KeyPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::KeyPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">Match</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vMatches12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>th2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbGood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>parallax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica la pose para confirmar hipótesis de H o F. </p>
<p>Invoca repetidamente <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a3bdf78e0f16be44b5ab312aac5cac5af" title="Triangula los puntos 3D partir de sus vistas desde ambas cámaras. ">Initializer::Triangulate</a> para obtener los puntos 3D que proyectan los puntos singulares. Los marca como "buenos" si no tienen coordenadas en infinito, están delante de las cámaras, el error de reproyección no supera el umbral argumento y tienen bajo paralaje (cosParallax&lt;0.99998).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Matriz rotación propuesta. </td></tr>
    <tr><td class="paramname">t</td><td>Vector traslación propuesto. </td></tr>
    <tr><td class="paramname">vKeys1</td><td>Puntos singulares en el cuadro 1. </td></tr>
    <tr><td class="paramname">vKeys2</td><td>Puntos singulares en el cuadro 2. </td></tr>
    <tr><td class="paramname">vMatches12</td><td>Macheos entre puntos singulares. </td></tr>
    <tr><td class="paramname">vnInliers</td><td>Señal de inlier. </td></tr>
    <tr><td class="paramname">K</td><td>Matriz de cámara. </td></tr>
    <tr><td class="paramname">vP3D</td><td>Resultado, puntos 3D triangulados. </td></tr>
    <tr><td class="paramname">th2</td><td>Umbral cuadrado, siempre 4*sigma2, máximo error de reproyección admitido para que el punto se considere bueno. </td></tr>
    <tr><td class="paramname">vbGood</td><td>Resultado, señal de punto triangulado "bueno", correspondientes a vKeys1, vKeys2, vMatches12, vnInliers y vP3D. </td></tr>
    <tr><td class="paramname">parallax</td><td>Resultado, paralaje promedio. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos buenos.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a60796f88f1b3e981ad925a8b566f6315" title="Verifica las 4 hipótesis de rototraslación obtenidas de la matriz fundamental. ">Initializer::ReconstructF</a> e <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#addc1c05d3b7a5ae35805f69b50f368ea" title="Verifica las 8 hipótesis de rototraslación de Faugeras obtenidas de la homografía. ">Initializer::ReconstructH</a>. </p>

</div>
</div>
<a id="aaca077af095ae1de08ebb473af670d1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::Initializer::ComputeF21 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computa la matriz fundamental para una dada correspondencia de puntos normalizados en dos imágenes, mediante SVD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vP1</td><td>Puntos singulares de un cuadro. </td></tr>
    <tr><td class="paramname">vP2</td><td>Puntos singulares correspondientes en el otro cuadro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matriz de homografía.</dd></dl>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a387c406706472859415c0e7a3594ea04" title="Computa la matriz fundamental entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindFundamental</a>. </p>

</div>
</div>
<a id="a16d5aa375ed03336cc0dc981861b15da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::Initializer::ComputeH21 </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computa una homografía para una dada correspondencia de puntos normalizados en dos imágenes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vP1</td><td>Puntos singulares de un cuadro. </td></tr>
    <tr><td class="paramname">vP2</td><td>Puntos singulares correspondientes en el otro cuadro. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matriz de homografía.</dd></dl>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a5b0465b2affed7453d30dd85672e9093" title="Busca la homografía entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindHomography</a>. </p>

</div>
</div>
<a id="a78e9e1a14ee76f6cab0f734fa95793af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Initializer::DecomposeE </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Descompone la matriz esencial E en matrices de rotación y vector traslación. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>Matriz esencial. </td></tr>
    <tr><td class="paramname">R1</td><td>Resultado, matriz de rotación 1 (primera hipótesis). </td></tr>
    <tr><td class="paramname">R2</td><td>Resultado, matriz de rotación 2 (segunda hipótesis). </td></tr>
    <tr><td class="paramname">t</td><td>Resultado, vector traslación para una hipótesis, su negativo para la otra.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocada sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a60796f88f1b3e981ad925a8b566f6315" title="Verifica las 4 hipótesis de rototraslación obtenidas de la matriz fundamental. ">Initializer::ReconstructF</a>. </p>

</div>
</div>
<a id="a387c406706472859415c0e7a3594ea04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Initializer::FindFundamental </td>
          <td>(</td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>F21</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computa la matriz fundamental entre los dos cuadros macheados, usando RANSAC. </p>
<p>Junto con FindHomography, son los dos métodos de inicialización que intentan obtener la pose inicial. Los tres argumentos reciben el resultado. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbInliers</td><td></td></tr>
    <tr><td class="paramname">score</td><td></td></tr>
    <tr><td class="paramname">F21</td><td>Matriz fundamental. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b0465b2affed7453d30dd85672e9093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Initializer::FindHomography </td>
          <td>(</td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbMatchesInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>H21</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Busca la homografía entre los dos cuadros macheados, usando RANSAC. </p>
<p>Junto con FindFundamental, son los dos métodos de inicialización que intentan obtener la pose inicial. Los tres argumentos sólo reciben el resultado. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbMatchesInliers</td><td>Vector booleano cuyos elementos indican si los puntos singulares correspondiente son inliers. </td></tr>
    <tr><td class="paramname">score</td><td>Puntaje de la homografía. Mayor, mejor. </td></tr>
    <tr><td class="paramname">H21</td><td>Matriz de transformación homográfica obtenida. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40d41840e2bdb7199ab024871d028c2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::Initializer::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>CurrentFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vMatches12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbTriangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computa en paralelo una matriz fundamental y una homografía. </p>
<p>Selecciona el modelo con mejor resultado e intenta obtener el movimiento y la estructura SFM (structure from motion). Intenta triangular los primeros puntos del mapa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentFrame</td><td>Cuadro actual. </td></tr>
    <tr><td class="paramname">vMatches12</td><td>Macheos. </td></tr>
    <tr><td class="paramname">R21</td><td>Matriz rotación de la segunda cámara respecto de la primera, resultado de la inicialización. </td></tr>
    <tr><td class="paramname">t21</td><td>Vector traslación de la segunda cámara respecto de la primera, resultado de la inicialización. </td></tr>
    <tr><td class="paramname">vP3D</td><td>Puntos 3D triangulados. </td></tr>
    <tr><td class="paramname">vbTriangulated</td><td>Indicador de inliers (true) u outliers (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si logró la triangulación, false si no. </dd></dl>

</div>
</div>
<a id="a44ce7aa73741d900d2becc0d8f14c1af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Initializer::Normalize </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; cv::KeyPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vNormalizedPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce puntos con las coordenadas normalizadas de los puntos singulares. </p>
<p>Normalizar consiste en colocar el origen en el punto medio, y que las distancias promedio al origen sean 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vKeys</td><td>Puntos singulares a normalizar. </td></tr>
    <tr><td class="paramname">vNormalizedPoints</td><td>Resultado, puntos con coordenadas normalizadas. </td></tr>
    <tr><td class="paramname">T</td><td>Resultado, matriz homogénea de 3x3, transformación de normalización.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a5b0465b2affed7453d30dd85672e9093" title="Busca la homografía entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindHomography</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a387c406706472859415c0e7a3594ea04" title="Computa la matriz fundamental entre los dos cuadros macheados, usando RANSAC. ">Initializer::FindFundamental</a>. </p>

</div>
</div>
<a id="a60796f88f1b3e981ad925a8b566f6315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::Initializer::ReconstructF </td>
          <td>(</td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbMatchesInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>F21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbTriangulated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minParallax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minTriangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica las 4 hipótesis de rototraslación obtenidas de la matriz fundamental. </p>
<p>Si hay suficientes inliers y paralaje, usa esa pose para inicializar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbMatchesInliers</td><td>Marca de maches válidos, inliers. </td></tr>
    <tr><td class="paramname">F21</td><td>Matriz fundamental. </td></tr>
    <tr><td class="paramname">K</td><td>Matriz de cámara, intrínseca o de calibración. </td></tr>
    <tr><td class="paramname">R21</td><td>Resultado: matriz de rotación de una cámara respecto de la otra. </td></tr>
    <tr><td class="paramname">t21</td><td>Resultado: vector traslación de una cámara respecto de la otra. </td></tr>
    <tr><td class="paramname">vP3D</td><td>Puntos 3D. </td></tr>
    <tr><td class="paramname">vbTriangulated</td><td></td></tr>
    <tr><td class="paramname">minParallax</td><td>Umbral mínimo de paralaje: 1.0. </td></tr>
    <tr><td class="paramname">minTriangulated</td><td>Cantidad mínima de puntos triangulados: 50. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si eligió el candidato para la inicialización.</dd></dl>
<p>Invocado sólo desde Initializer::initialize. </p>

</div>
</div>
<a id="addc1c05d3b7a5ae35805f69b50f368ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::Initializer::ReconstructH </td>
          <td>(</td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbMatchesInliers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>H21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; cv::Point3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vP3D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbTriangulated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minParallax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minTriangulated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifica las 8 hipótesis de rototraslación de Faugeras obtenidas de la homografía. </p>
<p>Si hay suficientes inliers y paralaje, usa esa pose para inicializar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vbMatchesInliers</td><td>Marca de maches válidos, inliers. </td></tr>
    <tr><td class="paramname">F21</td><td>Matriz fundamental. </td></tr>
    <tr><td class="paramname">K</td><td>Matriz de cámara, intrínseca o de calibración. </td></tr>
    <tr><td class="paramname">R21</td><td>Resultado: matriz de rotación de una cámara respecto de la otra. </td></tr>
    <tr><td class="paramname">t21</td><td>Resultado: vector traslación de una cámara respecto de la otra. </td></tr>
    <tr><td class="paramname">vP3D</td><td>Puntos 3D. </td></tr>
    <tr><td class="paramname">vbTriangulated</td><td></td></tr>
    <tr><td class="paramname">minParallax</td><td>Umbral mínimo de paralaje: 1.0. </td></tr>
    <tr><td class="paramname">minTriangulated</td><td>Cantidad mínima de puntos triangulados: 50. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si eligió el candidato para la inicialización.</dd></dl>
<p>Invocado sólo desde Initializer::initialize. </p>

</div>
</div>
<a id="a3bdf78e0f16be44b5ab312aac5cac5af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Initializer::Triangulate </td>
          <td>(</td>
          <td class="paramtype">const cv::KeyPoint &amp;&#160;</td>
          <td class="paramname"><em>kp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::KeyPoint &amp;&#160;</td>
          <td class="paramname"><em>kp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>x3D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangula los puntos 3D partir de sus vistas desde ambas cámaras. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kp1</td><td>Punto singular observado desde la cámara 1. </td></tr>
    <tr><td class="paramname">kp2</td><td>Punto singular observado desde la cámara 2. </td></tr>
    <tr><td class="paramname">P1</td><td>Matriz de proyección de la cámara 1: K[I|0]. Matriz de 4x3 basada en la matriz de cámara. </td></tr>
    <tr><td class="paramname">P2</td><td>Matriz de proyección de la cámara 2: K[R|t]. Matriz de 4x3 basada en la matriz de cámara y la pose relativa a la cámara 1. </td></tr>
    <tr><td class="paramname">x3D</td><td>Resultado, coordenadas euclideanas del punto 3D triangulado por SVD, en el sistema de coordenadas de la cámara 1.</td></tr>
  </table>
  </dd>
</dl>
<p>Usa cv::SVD para triangular.</p>
<p>La matriz de proyección P de una cámara es una matriz de 4x3 (3 filas, 4 columnas), que combina sus matrices intrínseca y extrínseca. P = K[R|t], siendo K la matriz de cámara, R y t la rototraslación de la cámara respecto de la referencia. Premultiplicando una coordenada 3D homogénea (vector de 4 dimensiones), se obtiene su proyección en coordenadas homogéneas en píxeles.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#a72e79f6486468cde9abd87b873d840e7" title="Verifica la pose para confirmar hipótesis de H o F. ">Initializer::CheckRT</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a557fe4d78becc1dda7a26c71d2254336"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::Initializer::mK</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matriz de calibración, intrínseca o de cámara. </p>

</div>
</div>
<a id="a8d9647dedc212bd1fe05084ec7875a05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Initializer::mMaxIterations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cantidad máxima de iteraciones al aplicar RanSaC. </p>

</div>
</div>
<a id="ad588868e84cb1b7e256928dd0d50baee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::Initializer::mSigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Desvío estándar y variancia. </p>

</div>
</div>
<a id="a7af4e0e177bb75879dac174b758ce7d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::Initializer::mSigma2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a90762e82702f06f6999672ebaa4cb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; ORB_SLAM2::Initializer::mvbMatched1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marcas de macheos. </p>

</div>
</div>
<a id="aa4a8bce28d125446b4607f12041c7c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;cv::KeyPoint&gt; ORB_SLAM2::Initializer::mvKeys1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puntos singulares del cuadro 1. </p>

</div>
</div>
<a id="a034e9d495b47667f3e0bf0bc3190ff05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;cv::KeyPoint&gt; ORB_SLAM2::Initializer::mvKeys2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puntos singulares del cuadro 2. </p>

</div>
</div>
<a id="ac4ef04be7036e4629a8b3fa05c7327f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html#ad0bf21297bc6271e7d014ce41d6ff7d4">Match</a>&gt; ORB_SLAM2::Initializer::mvMatches12</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Macheos. </p>

</div>
</div>
<a id="a572144f600b28828d4772b0470206afe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;size_t&gt; &gt; ORB_SLAM2::Initializer::mvSets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conjuntos para Ransac. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_initializer_8h_source.html">Initializer.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_initializer_8cc.html">Initializer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_initializer.html">Initializer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
